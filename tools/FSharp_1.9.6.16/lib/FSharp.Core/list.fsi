//=========================================================================
// (c) Microsoft Corporation 2005-2009. 
//=========================================================================

namespace Microsoft.FSharp.Collections

    open System
    open System.Collections.Generic
    open Microsoft.FSharp.Core
    open Microsoft.FSharp.Collections

    /// Basic operations on lists.  
    [<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
    [<RequireQualifiedAccess>]
    module List = 

        /// Return a new list that contains the elements of the first list
        /// followed by elements of the second
        val append: list1:'T list -> list2:'T list -> 'T list

        /// Return the average of the elements in the list.
        /// If the list is empty an ArgumentException is thrown.
        val inline average   : list:^T list -> ^T    
                                   when ^T : (static member ( + ) : ^T * ^T -> ^T) 
                                   and  ^T : (static member DivideByInt : ^T*int -> ^T) 
                                   and  ^T : (static member Zero : ^T)

        /// Return the average of the elements generated by applying the function to each element of the list.
        /// If the list is empty an ArgumentException is thrown.
        val inline averageBy   : projection:('T -> ^U) -> list:'T list  -> ^U    
                                   when ^U : (static member ( + ) : ^U * ^U -> ^U) 
                                   and  ^U : (static member DivideByInt : ^U*int -> ^U) 
                                   and  ^U : (static member Zero : ^U)

        /// Apply the given function to each element of the list. Return
        /// the list comprised of the results <c>x</c> for each element where
        /// the function returns Some(x)
        val choose: chooser:('T -> 'U option) -> list:'T list -> 'U list

        /// For each element of the list, apply the given function. Concatenate all the results and return the combined list.
        val collect: mapping:('T -> 'U list) -> list:'T list -> 'U list

        /// Return a new list that contains the elements of each the lists in order
        val concat: lists:seq<'T list> -> 'T list

        /// Return an empty list of the given type
        [<GeneralizableValue>]
        val empty<'T> : 'T list

        /// Test if any element of the list satisfies the given predicate.
        ///
        /// The predicate is applied to the elements of the input list. If any application 
        /// returns true then the overall result is true and no further elements are tested. 
        /// Otherwise, false is returned.
        val exists: predicate:('T -> bool) -> list:'T list -> bool

        /// Test if any pair of corresponding elements of the lists satisfies the given predicate.
        ///
        /// The predicate is applied to matching elements in the two collections up to the lesser of the 
        /// two lengths of the collections. If any application returns true then the overall result is 
        /// true and no further elements are tested. Otherwise, if one collections is longer 
        /// than the other then the <c>ArgumentException</c> exception is raised. 
        /// Otherwise, false is returned.
        val exists2: predicate:('T1 -> 'T2 -> bool) -> list1:'T1 list -> list2:'T2 list -> bool

        /// Return the first element for which the given function returns <c>true</c>.
        /// Raise <c>KeyNotFoundException</c> if no such element exists.
        val find: predicate:('T -> bool) -> list:'T list -> 'T

        /// Return the index of the first element in the list
        /// that satisfies the given predicate.
        /// Raise <c>KeyNotFoundException</c> if no such element exists.
        val findIndex: predicate:('T -> bool) -> list:'T list -> int

        /// Return a new collection containing only the elements of the collection
        /// for which the given predicate returns "true"
        val filter: predicate:('T -> bool) -> list:'T list -> 'T list

        /// Apply a function to each element of the collection, threading an accumulator argument
        /// through the computation. Take the second argument, and apply the function to it
        /// and the first element of the list.  Then feed this result into the function along
        /// with the second element and so on.  Return the final result.
        /// If the input function is <c>f</c> and the elements are <c>i0...iN</c> then 
        /// computes <c>f (... (f s i0) i1 ...) iN</c>
        val fold: folder:('State -> 'T -> 'State) -> state:'State -> list:'T list -> 'State

        /// Apply a function to corresponding elements of two collections, threading an accumulator argument
        /// through the computation. The collections must have identical sizes.
        /// If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jN</c>
        /// then computes <c>f (... (f s i0 j0)...) iN jN</c>.
        val fold2: folder:('State -> 'T1 -> 'T2 -> 'State) -> state:'State -> list1:'T1 list -> list2:'T2 list -> 'State

        /// Apply a function to each element of the collection, threading an accumulator argument
        /// through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then 
        /// computes <c>f i0 (...(f iN s))</c>.
        val foldBack: folder:('T -> 'State -> 'State) -> list:'T list -> state:'State -> 'State

        /// Apply a function to corresponding elements of two collections, threading an accumulator argument
        /// through the computation. The collections must have identical sizes.
        /// If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jN</c>
        /// then computes <c>f i0 j0 (...(f iN jN s))</c>.
        val foldBack2: folder:('T1 -> 'T2 -> 'State -> 'State) -> list1:'T1 list -> list2:'T2 list -> state:'State -> 'State

        /// Test if all elements of the collection satisfy the given predicate.
        ///
        /// The predicate is applied to the elements of the input list. If any application 
        /// returns false then the overall result is false and no further elements are tested. 
        /// Otherwise, true is returned.
        val forall: predicate:('T -> bool) -> list:'T list -> bool

        /// Test if all corresponding elements of the collection satisfy the given predicate pairwise.
        ///
        /// The predicate is applied to matching elements in the two collections up to the lesser of the 
        /// two lengths of the collections. If any application returns false then the overall result is 
        /// false and no further elements are tested. Otherwise, if one collection is longer 
        /// than the other then the <c>ArgumentException</c> exception is raised. 
        /// Otherwise, true is returned.
        val forall2: predicate:('T1 -> 'T2 -> bool) -> list1:'T1 list -> list2:'T2 list -> bool

        /// Return the first element of the list.  Raise (Invalid_argument "hd") if undefined.
        val hd: list:'T list -> 'T

        /// Create a list by calling the given generator on each index
        val init: length:int -> initializer:(int -> 'T) -> 'T list

        /// Return true if the list contains no elements, false otherwise
        val isEmpty: list:'T list -> bool

        /// Apply the given function to each element of the collection. 
        val iter: action:('T -> unit) -> list:'T list -> unit

        /// Apply the given function to two collections simultaneously. The
        /// collections must have identical size.
        val iter2: action:('T1 -> 'T2 -> unit) -> list1:'T1 list -> list2:'T2 list -> unit

        /// Apply the given function to each element of the collection. The integer passed to the
        /// function indicates the index of element.
        val iteri: action:(int -> 'T -> unit) -> list:'T list -> unit

        /// Apply the given function to two collections simultaneously. The
        /// collections must have identical size. The integer passed to the
        /// function indicates the index of element.
        val iteri2: action:(int -> 'T1 -> 'T2 -> unit) -> list1:'T1 list -> list2:'T2 list -> unit

        /// Return the length of the list
        val length: list:'T list -> int

        /// Build a new collection whose elements are the results of applying the given function
        /// to each of the elements of the collection.
        val map: mapping:('T -> 'U) -> list:'T list -> 'U list

        /// Build a new collection whose elements are the results of applying the given function
        /// to the corresponding elements of the two collections pairwise.
        val map2: mapping:('T1 -> 'T2 -> 'U) -> list1:'T1 list -> list2:'T2 list -> 'U list

        /// Build a new collection whose elements are the results of applying the given function
        /// to the corresponding elements of the three collections simultaneously.
        val map3: mapping:('T1 -> 'T2 -> 'T3 -> 'U) -> list1:'T1 list -> list2:'T2 list -> list3:'T3 list -> 'U list

        /// Build a new collection whose elements are the results of applying the given function
        /// to each of the elements of the collection. The integer index passed to the
        /// function indicates the index (from 0) of element being transformed.
        val mapi: mapping:(int -> 'T -> 'U) -> list:'T list -> 'U list

        /// Like mapi, but mapping corresponding elements from two lists of equal length.
        val mapi2: mapping:(int -> 'T1 -> 'T2 -> 'U) -> list1:'T1 list -> list2:'T2 list -> 'U list

        /// Return the greatest of all elements of the list, compared via Operators.max
        val max     : list:'T list -> 'T 

        /// Return the greatest of all elements of the array, compared via Operators.max on the function result
        val maxBy   : projection:('T -> 'U) -> list:'T list -> 'T

        /// Return the lowest of all elements of the list, compared via Operators.min
        val min     : list:'T list -> 'T 

        /// Return the lowest of all elements of the array, compared via Operators.min on the function result
        val minBy   : projection:('T -> 'U) -> list:'T list -> 'T

        /// Index into the list.  The first element has index 0.
        val nth: list:'T list -> index:int -> 'T

        /// Build a collection from the given array
        val of_array : array:'T array -> 'T list

        /// Build a new collection from the given enumerable object
        val of_seq: elements:seq<'T> -> 'T list

        /// Split the collection into two collections, containing the 
        /// elements for which the given predicate returns <c>true</c> and <c>false</c>
        /// respectively 
        val partition: predicate:('T -> bool) -> list:'T list -> ('T list * 'T list)

        /// Apply the given function to successive elements, returning the first
        /// result where function returns <c>Some(x)</c> for some x. If no such
        /// element exists then raise <c>System.Collections.Generic.KeyNotFoundException</c>
        val pick: chooser:('T -> 'U option) -> list:'T list -> 'U

        /// Returns a list with all elements permuted according to the
        /// specified permutation
        val permute : indexMap:(int -> int) -> list:'T list -> 'T list

        /// Apply a function to each element of the collection, threading an accumulator argument
        /// through the computation. Apply the function to the first two elements of the list.
        /// Then feed this result into the function along with the third element and so on.  
        /// Return the final result. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
        /// <c>f (... (f i0 i1) i2 ...) iN</c>.
        /// Raises ArgumentException if the list has no elements.      
        val reduce: reduction:('T -> 'T -> 'T) -> list:'T list -> 'T

        /// Apply a function to each element of the collection, threading an accumulator argument
        /// through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
        /// <c>f i0 (...(f iN-1 iN))</c>.
        /// Raises ArgumentException if the list has no elements.
        val reduceBack: reduction:('T -> 'T -> 'T) -> list:'T list -> 'T

        /// Create a list by calling the given generator on each index
        val replicate: count:int -> initial:'T -> 'T list

        /// Return a new list with the elements in reverse order
        val rev: list:'T list -> 'T list

        /// Apply a function to each element of the collection, threading an accumulator argument
        /// through the computation. Take the second argument, and apply the function to it
        /// and the first element of the list.  Then feed this result into the function along
        /// with the second element and so on.  Return the list of intermediate results and the final result.
        val scan : folder:('State -> 'T -> 'State) -> state:'State -> list:'T list -> 'State list

        /// Like <c>foldBack</c>, but return both the intermediary and final results
        val scanBack : folder:('T -> 'State -> 'State) -> list:'T list -> state:'State -> 'State list

        /// Sort the given list using the given comparison function
        val sortWith: comparer:('T -> 'T -> int) -> list:'T list -> 'T list

        /// Sort the given list using keys given by the given projection. Keys are compared using Operators.compare. 
        val sortBy: projection:('T -> 'U) -> list:'T list -> 'T list

        /// Sort the given list using the given comparison function
        val sort: list:'T list -> 'T list

        /// Return the sum of the elements in the list
        val inline sum   : list:^T list -> ^T 
                                   when ^T : (static member ( + ) : ^T * ^T -> ^T) 
                                   and  ^T : (static member Zero : ^T)

        /// Return the sum of the results generated by applying the function to each element of the list.
        val inline sumBy : projection:('T -> ^U) -> list:'T list -> ^U 
                                   when ^U : (static member ( + ) : ^U * ^U -> ^U) 
                                   and  ^U : (static member Zero : ^U)

        /// Return the tail of the list.  Raise (Invalid_argument "tl") if undefined.
        val tl: list:'T list -> 'T list

        /// Build an array from the given collection
        val to_array: list:'T list -> 'T array

        /// Build a new collection from the given enumerable object
        val to_seq: list:list<'T> -> seq<'T>

        /// Apply the given function to successive elements, returning <c>Some(x)</c> the first
        /// result where function returns <c>Some(x)</c> for some x. If no such element 
        /// exists then return <c>None</c>
        val tryPick: chooser:('T -> 'U option) -> list:'T list -> 'U option

        /// Return the first element for which the given function returns <c>true</c>.
        /// Return <c>None</c> if no such element exists.
        val tryFind: predicate:('T -> bool) -> list:'T list -> 'T option

        /// Return the index of the first element in the list
        /// that satisfies the given predicate.
        /// Return <c>None</c> if no such element exists.
        val tryFindIndex: predicate:('T -> bool) -> list:'T list -> int option

        /// Split a list of pairs into two lists
        val unzip: list:('T1 * 'T2) list -> ('T1 list * 'T2 list)

        /// Split a list of triples into three lists
        val unzip3: list:('T1 * 'T2 * 'T3) list -> ('T1 list * 'T2 list * 'T3 list)

        /// Combine the two lists into a list of pairs. The two lists must have equal lengths.
        val zip: list1:'T1 list -> list2:'T2 list -> ('T1 * 'T2) list

        /// Combine the three lists into a list of triples. The lists must have equal lengths.
        val zip3: list1:'T1 list -> list2:'T2 list -> list3:'T3 list -> ('T1 * 'T2 * 'T3) list

#if DONT_INCLUDE_DEPRECATED
#else
        [<Obsolete("This F# library function has been renamed. Use 'averageBy' instead")>]
        val inline average_by   : projection:('T -> ^U) -> list:'T list  -> ^U    when ^U : (static member ( + ) : ^U * ^U -> ^U) 
                                                                 and  ^U : (static member DivideByInt : ^U*int -> ^U) 
                                                                 and  ^U : (static member Zero : ^U)

        [<Obsolete("This F# library function has been renamed. Use 'collect' instead")>]
        val map_concat: mapping:('T -> 'U list) -> list:'T list -> 'U list

        [<OCamlCompatibility("This F# library function has been renamed. Use 'concat' instead")>]
        val flatten: lists:seq<'T list> -> 'T list

        [<Obsolete("This F# library function has been renamed. Use 'findIndex' instead")>]
        val find_index: predicate:('T -> bool) -> list:'T list -> int

        [<OCamlCompatibility("This F# library function has been renamed. Use 'filter' instead")>]
        val find_all: predicate:('T -> bool) -> list:'T list -> 'T list

        [<OCamlCompatibility("This F# library function has been renamed. Use 'fold' instead")>]
        val fold_left: folder:('State -> 'T -> 'State) -> state:'State -> list:'T list -> 'State

        [<OCamlCompatibility("This F# library function has been renamed. Use 'fold2' instead")>]
        val fold_left2: folder:('State -> 'T1 -> 'T2 -> 'State) -> state:'State -> list1:'T1 list -> list2:'T2 list -> 'State

        [<OCamlCompatibility("This F# library function has been renamed. Use 'foldBack' instead")>]
        val fold_right: folder:('T -> 'State -> 'State) -> list:'T list -> state:'State -> 'State

        [<OCamlCompatibility("This F# library function has been renamed. Use 'foldBack2' instead")>]
        val fold_right2: folder:('T1 -> 'T2 -> 'State -> 'State) -> list1:'T1 list -> list2:'T2 list -> state:'State -> 'State

        [<OCamlCompatibility("This F# library function has been renamed. Use 'forall' instead")>]
        val for_all: predicate:('T -> bool) -> list:'T list -> bool

        [<Obsolete("This F# library function has been renamed. Use 'forall2' instead")>]
        val for_all2: predicate:('T1 -> 'T2 -> bool) -> list1:'T1 list -> list2:'T2 list -> bool

        [<Obsolete("This F# library function has been renamed. Use 'isEmpty' instead")>]
        val is_empty: list:'T list -> bool

        [<Obsolete("This F# library function has been renamed. Use 'maxBy' instead")>]
        val max_by   : projection:('T -> 'U) -> list:'T list -> 'T
        
        [<Obsolete("This F# library function has been renamed. Use 'minBy' instead")>]
        val min_by   : projection:('T -> 'U) -> list:'T list -> 'T

        [<Obsolete("This F# library function has been renamed. Use 'reduce' instead")>]
        val reduce_left: reduction:('T -> 'T -> 'T) -> list:'T list -> 'T

        [<Obsolete("This F# library function has been renamed. Use 'reduceBack' instead")>]
        val reduce_right: reduction:('T -> 'T -> 'T) -> list:'T list -> 'T

        [<Obsolete("This F# library function has been renamed. Use 'scan' instead")>]
        val scan_left : folder:('State -> 'T -> 'State) -> state:'State -> list:'T list -> 'State list

        [<Obsolete("This F# library function has been renamed. Use 'scanBack' instead")>]
        val scan_right : folder:('T -> 'State -> 'State) -> list:'T list -> state:'State -> 'State list
        
        [<Obsolete("This F# library function has been renamed. Use 'sortBy' instead")>]
        val sort_by: projection:('T -> 'U) -> list:'T list -> 'T list

        [<OCamlCompatibility("This F# library function has been renamed. Use 'sortWith' instead")>]
        val stable_sort: list: ('T -> 'T -> int) -> 'T list -> 'T list

        [<Obsolete("This F# library function has been renamed. Use 'sumBy' instead")>]
        val inline sum_by : projection:('T -> ^U) -> list:'T list -> ^U 
                                   when ^U : (static member ( + ) : ^U * ^U -> ^U) 
                                   and  ^U : (static member Zero : ^U)

        [<Obsolete("This F# library function has been renamed. Use 'tryPick' instead")>]
        val first: chooser:('T -> 'U option) -> list:'T list -> 'U option

        [<Obsolete("This F# library function has been renamed. Use 'tryFind' instead")>]
        val tryfind: predicate:('T -> bool) -> list:'T list -> 'T option

        [<Obsolete("This F# library function has been renamed. Use 'tryFindIndex' instead")>]
        val tryfind_index: predicate:('T -> bool) -> list:'T list -> int option

        [<OCamlCompatibility("This F# library function has been renamed. Use 'unzip' instead")>]
        val split: list:('T1 * 'T2) list -> ('T1 list * 'T2 list)

        [<OCamlCompatibility("This F# library function has been renamed. Use 'zip' instead")>]
        val combine: list1:'T1 list -> list2:'T2 list -> ('T1 * 'T2) list

#endif



<HTML><HEAD><TITLE>Microsoft.FSharp.Collections.Seq</TITLE><link rel="stylesheet" type="text/css"href="../msdn.css"></link></HEAD><BODY>
<br><dl>
<dt></dt><dd>
<h1>[<a href='../namespaces.html'>Home</a>] Module <a href='Microsoft.FSharp.Collections.html'>Microsoft.FSharp.Collections</a>.Seq </h1><br>
</dd>
<dt></dt><dd>
<table>
  <tr valign='top'><td><summary>
 Basic operations on IEnumerables.  
</summary>
  <dt><h3>Values</h3></dt><dd>
<table width="100%%">
<tr><th width=60%>Value</th><th>Description</th></tr>
<tr valign="top"><td><pre>val append : <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Wrap the two given enumeration-of-enumerations as a single concatenated
 enumeration.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary></td></tr>
<tr valign="top"><td><pre>val average : overloaded</pre></td><td><summary>
 Return the average of the elements in the sequence

 The elements are averaged using the '+' operator, 'DivideByInt' method and 'Zero' property 
 associated with the element type.
</summary></td></tr>
<tr valign="top"><td><pre>val averageBy : overloaded</pre></td><td><summary>
 Return the average of the results generated by applying the function to each element of the sequence.

 The elements are averaged using the '+' operator, 'DivideByInt' method and 'Zero' property 
 associated with the generated type.
</summary></td></tr>
<tr valign="top"><td><pre>val cache : <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Return a sequence that corresponds to a cached version of the input sequence.
 This result sequence will have the same elements as the input sequence. The result 
 can be enumerated multiple times. The input sequence will be enumerated at most 
 once and only as far as is necessary.

 Enumeration of the result sequence is thread safe in the sense that multiple independent IEnumerator
 values may be used simultaneously from different threads (accesses to 
 the internal lookaside table are thread safe). Each individual IEnumerator
 is not typically thread safe and should not be accessed concurrently.

 Note, once enumeration of the input sequence has started,
 it's enumerator will be kept live by this object until the enumeration has completed.
 At that point, the enumerator will be disposed. 

 The enumerator may be disposed and underlying cache storage released by 
 converting the returned sequence object to type IDisposable, and calling the Dispose method
 on this object. The sequence object may then be re-enumerated and a fresh enumerator will
 be used.
</summary></td></tr>
<tr valign="top"><td><pre>val cast : <a href='http://msdn2.microsoft.com/en-us/library/System.Collections.IEnumerable.aspx'>IEnumerable</a> -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Wrap a loosely-typed System.Collections sequence as a typed sequence.

 The use of this function usually requires a type annotation.
 An incorrect type annotation may result in runtime type
 errors.

 Individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary></td></tr>
<tr valign="top"><td><pre>val choose : ('T -> 'U <a href='Microsoft.FSharp.Core.type__option-1.html'>option</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'U&gt;</pre></td><td><summary>
 Apply the given function to each element of the list. Return
 the list comprised of the results "x" for each element where
 the function returns Some(x)

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.

 Remember sequence is lazy, effects are delayed until it is enumerated.
</summary></td></tr>
<tr valign="top"><td><pre>val collect : ('T -> #<a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'U&gt;) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'U&gt;</pre></td><td><summary>
 For each element of the enumeration apply the given function and concatenate all the results.

 Remember sequence is lazy, effects are delayed until it is enumerated.    
</summary></td></tr>
<tr valign="top"><td><pre>val compare : ('T -> 'T -> <a href='Microsoft.FSharp.Core.type__int.html'>int</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Core.type__int.html'>int</a></pre></td><td><summary>
 Compare two sequence's using generic comparison, element by element.
</summary></td></tr>
<tr valign="top"><td><pre>val compareWith : ('T -> 'T -> <a href='Microsoft.FSharp.Core.type__int.html'>int</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Core.type__int.html'>int</a></pre></td><td><summary>
 Compare two sequence's using the given comparison function, element by element.
</summary></td></tr>
<tr valign="top"><td><pre>val concat : <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;#<a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Wrap the given enumeration-of-enumerations as a single concatenated
 enumeration.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary></td></tr>
<tr valign="top"><td><pre>val countBy : ('T -> 'Key) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'Key * <a href='Microsoft.FSharp.Core.type__int.html'>int</a>&gt;</pre></td><td><summary>
 Apply a key-generating function to each element of a sequence and return a sequence yielding unique
 keys and their number of occurences in the original sequence.  
 
 Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.
</summary></td></tr>
<tr valign="top"><td><pre>val delay : (<a href='Microsoft.FSharp.Core.type__unit.html'>unit</a> -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Return a sequence that is built from the given delayed specification of an
 Seq. The input function is evaluated each time an IEnumerator for the sequence 
 is requested.
</summary></td></tr>
<tr valign="top"><td><pre>val distinct : <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Return a sequence that contains no duplicate entries according to generic hash and equality comparisons on the entries.
 If an element occurs multiple times in the sequence then the later occurrences are discarded.
</summary></td></tr>
<tr valign="top"><td><pre>val distinctBy : ('T -> 'Key) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Return a sequence that contains no duplicate entries according to the 
 generic hash and equality comparisons on the keys returned by the given key-generating function.
 If an element occurs multiple times in the sequence then the later occurrences are discarded.
</summary></td></tr>
<tr valign="top"><td><pre>[<<a href='Microsoft.FSharp.Core.type_GeneralizableValueAttribute.html'>GeneralizableValueAttribute</a> ()>]
val empty&lt;'T&gt; : <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Create an empty sequence 
</summary></td></tr>
<tr valign="top"><td><pre>val exists : ('T -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a></pre></td><td><summary>
 Test if any element of the sequence satisfies the given predicate.

 The predicate is applied to the elements of the input sequence. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.
</summary></td></tr>
<tr valign="top"><td><pre>val exists2 : ('T1 -> 'T2 -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T1&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T2&gt; -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a></pre></td><td><summary>
 Test if any pair of corresponding elements of the input sequences satisfies the given predicate.

 The predicate is applied to matching elements in the two sequences up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, false is returned. If one sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.
</summary></td></tr>
<tr valign="top"><td><pre>val filter : ('T -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns "true"

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.

 Remember sequence is lazy, effects are delayed until it is enumerated.      
</summary></td></tr>
<tr valign="top"><td><pre>val find : ('T -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> 'T</pre></td><td><summary>
 Return the first element for which the given function returns <tt>true</tt>.
 Raise <tt>KeyNotFoundException</tt> if no such element exists.
</summary></td></tr>
<tr valign="top"><td><pre>val findIndex : ('T -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Core.type__int.html'>int</a></pre></td><td><summary>
 Return the index of the first element in the sequence of pairs
 that satisfies the given predicate. Raise <tt>KeyNotFoundException</tt> if no such element exists.
</summary></td></tr>
<tr valign="top"><td><pre>val fold : ('State -> 'T -> 'State) -> 'State -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> 'State</pre></td><td><summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <tt>f</tt> and the elements are <tt>i0...iN</tt> 
 then computes <tt>f (... (f s i0)...) iN</tt>
</summary></td></tr>
<tr valign="top"><td><pre>val forall : ('T -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a></pre></td><td><summary>
 Test if all elements of the sequence satisfy the given predicate.

 The predicate is applied to the elements of the input sequence. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.
</summary></td></tr>
<tr valign="top"><td><pre>val forall2 : ('T1 -> 'T2 -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T1&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T2&gt; -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a></pre></td><td><summary>
 Test the all pairs of elements drawn from the two sequences satisfies the
 given predicate. If one sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored
</summary></td></tr>
<tr valign="top"><td><pre>val groupBy : ('T -> 'Key) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'Key * <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;&gt;</pre></td><td><summary>
 Apply a key-generating function to each element of a sequence and yields a sequence of 
 unique keys. Each unique key has also contains a sequence of all elements that match 
 to this key. 
 
 Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.
</summary></td></tr>
<tr valign="top"><td><pre>val hd : <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> 'T</pre></td><td><summary>
 Return the first element of the sequence.  
</summary></td></tr>
<tr valign="top"><td><pre>val init : <a href='Microsoft.FSharp.Core.type__int.html'>int</a> -> (<a href='Microsoft.FSharp.Core.type__int.html'>int</a> -> 'T) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Generate a new sequence which, when iterated, will return successive
 elements by calling the given function, up to the given count.  The results of calling the function
 will not be saved, i.e. the function will be reapplied as necessary to
 regenerate the elements.  The function is passed the index of the item being
 generated.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary></td></tr>
<tr valign="top"><td><pre>val initInfinite : (<a href='Microsoft.FSharp.Core.type__int.html'>int</a> -> 'T) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Generate a new sequence which, when iterated, will return successive
 elements by calling the given function.  The results of calling the function
 will not be saved, i.e. the function will be reapplied as necessary to
 regenerate the elements.  The function is passed the index of the item being
 generated

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary></td></tr>
<tr valign="top"><td><pre>val isEmpty : <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a></pre></td><td><summary>
 Return true if the sequence contains no elements, false otherwise
</summary></td></tr>
<tr valign="top"><td><pre>val iter : ('T -> <a href='Microsoft.FSharp.Core.type__unit.html'>unit</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Core.type__unit.html'>unit</a></pre></td><td><summary>
 Apply the given function to each element of the collection. 
</summary></td></tr>
<tr valign="top"><td><pre>val iter2 : ('T1 -> 'T2 -> <a href='Microsoft.FSharp.Core.type__unit.html'>unit</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T1&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T2&gt; -> <a href='Microsoft.FSharp.Core.type__unit.html'>unit</a></pre></td><td><summary>
 Apply the given function to two collections simultaneously. If one sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.
</summary></td></tr>
<tr valign="top"><td><pre>val iteri : (<a href='Microsoft.FSharp.Core.type__int.html'>int</a> -> 'T -> <a href='Microsoft.FSharp.Core.type__unit.html'>unit</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Core.type__unit.html'>unit</a></pre></td><td><summary>
 Apply the given function to each element of the collection. The integer passed to the
 function indicates the index of element.
</summary></td></tr>
<tr valign="top"><td><pre>val length : <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Core.type__int.html'>int</a></pre></td><td><summary>
 Return the length of the sequence
</summary></td></tr>
<tr valign="top"><td><pre>val map : ('T -> 'U) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'U&gt;</pre></td><td><summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.  The given function will be applied
 as elements are demanded using the 'MoveNext' method on enumerators retrieved from the
 object.  

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary></td></tr>
<tr valign="top"><td><pre>val map2 :
  ('T1 -> 'T2 -> 'U) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T1&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T2&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'U&gt;</pre></td><td><summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.
</summary></td></tr>
<tr valign="top"><td><pre>val mapi : (<a href='Microsoft.FSharp.Core.type__int.html'>int</a> -> 'T -> 'U) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'U&gt;</pre></td><td><summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The integer index passed to the
 function indicates the index (from 0) of element being transformed.
</summary></td></tr>
<tr valign="top"><td><pre>val max : <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> 'T</pre></td><td><summary>
 Return the greatest of all elements of the sequence, compared via Operators.max
</summary></td></tr>
<tr valign="top"><td><pre>val maxBy : ('T -> 'Key) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> 'T</pre></td><td><summary>
 Return the greatest of all elements of the array, compared via Operators.max on the function result
</summary></td></tr>
<tr valign="top"><td><pre>val min : <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> 'T</pre></td><td><summary>
 Return the lowest of all elements of the sequence, compared via Operators.min
</summary></td></tr>
<tr valign="top"><td><pre>val minBy : ('T -> 'Key) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> 'T</pre></td><td><summary>
 Return the lowest of all elements of the array, compared via Operators.min on the function result
</summary></td></tr>
<tr valign="top"><td><pre>val nth : <a href='Microsoft.FSharp.Core.type__int.html'>int</a> -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> 'T</pre></td><td><summary>
 Compute the nth element in the collection.
</summary></td></tr>
<tr valign="top"><td><pre>val of_array : 'T <a href='Microsoft.FSharp.Core.type__array-1.html'>array</a> -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Build a collection from the given array
</summary></td></tr>
<tr valign="top"><td><pre>val of_list : 'T <a href='Microsoft.FSharp.Collections.type__list-1.html'>list</a> -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Build a collection from the given array
</summary></td></tr>
<tr valign="top"><td><pre>val pairwise : <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T * 'T&gt;</pre></td><td><summary>
 Return a sequence of each element in the input sequence and its predecessor, with the
 exception of the first element which is only returned as the predecessor of the second element.
</summary></td></tr>
<tr valign="top"><td><pre>val pick : ('T -> 'U <a href='Microsoft.FSharp.Core.type__option-1.html'>option</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> 'U</pre></td><td><summary>
 Apply the given function to successive elements, returning the first
 'x' where the function returns "Some(x)".
</summary></td></tr>
<tr valign="top"><td><pre>val readonly : <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Build a new sequence object that delegates to the given sequence object. This ensures 
 the original sequence can't be rediscovered and mutated by a type cast. For example, 
 if given an array the returned sequence will return the elements of the array, but
 you can't cast the returned sequence object to an array.
</summary></td></tr>
<tr valign="top"><td><pre>val reduce : ('T -> 'T -> 'T) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> 'T</pre></td><td><summary>
 Apply a function to each element of the sequence, threading an accumulator argument
 through the computation. Begin by applying the function to the first two elements.
 Then feed this result into the function along with the third element and so on.  
 Return the final result.
 Raises ArgumentException if the sequence has no elements.    
</summary></td></tr>
<tr valign="top"><td><pre>val scan :
  ('State -> 'T -> 'State) -> 'State -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'State&gt;</pre></td><td><summary>
 Like fold, but compute on-demand and return the sequence of intermediary and final results
</summary></td></tr>
<tr valign="top"><td><pre>val singleton : 'T -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Return a sequence that yields one item only.
</summary></td></tr>
<tr valign="top"><td><pre>val skip : <a href='Microsoft.FSharp.Core.type__int.html'>int</a> -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Return a sequence that skips N elements of the underlying sequence and then yields the
 remaining elements of the sequence
</summary></td></tr>
<tr valign="top"><td><pre>val skipWhile : ('T -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Return a sequence that, when iterated, skips elements of the underlying sequence while the 
 given predicate returns 'true', and then yields the remaining elements of the sequence
</summary></td></tr>
<tr valign="top"><td><pre>val sort : <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Yield a sequence ordered by keys.  
 
 Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.
</summary></td></tr>
<tr valign="top"><td><pre>val sortBy : ('T -> 'Key) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Apply a key-generating function to each element of a sequence and yield a sequence ordered
 by keys.  The keys are compared using generic comparison as implemented by <tt>Operators.compare</tt>. 
 
 Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.
</summary></td></tr>
<tr valign="top"><td><pre>val sum : overloaded</pre></td><td><summary>
 Return the sum of the elements in the sequence.

 The elements are summed using the '+' operator and 'Zero' property associated with the generated type.
</summary></td></tr>
<tr valign="top"><td><pre>val sumBy : overloaded</pre></td><td><summary>
 Return the sum of the results generated by applying the function to each element of the sequence.
 The generated elements are summed using the '+' operator and 'Zero' property associated with the generated type.
</summary></td></tr>
<tr valign="top"><td><pre>val take : <a href='Microsoft.FSharp.Core.type__int.html'>int</a> -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Return the first N elements of the sequence.  
</summary></td></tr>
<tr valign="top"><td><pre>val takeWhile : ('T -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Return a sequence that, when iterated, yields elements of the underlying sequence while the 
 given predicate returns 'true', and returns no further elements 
</summary></td></tr>
<tr valign="top"><td><pre>val to_array : <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> 'T <a href='Microsoft.FSharp.Core.type__array-1.html'>array</a></pre></td><td><summary>
 Build an array from the given collection
</summary></td></tr>
<tr valign="top"><td><pre>val to_list : <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> 'T <a href='Microsoft.FSharp.Collections.type__list-1.html'>list</a></pre></td><td><summary>
 Build a list from the given collection
</summary></td></tr>
<tr valign="top"><td><pre>val truncate : <a href='Microsoft.FSharp.Core.type__int.html'>int</a> -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Return a sequence that when enumerated returns at most N elements.
</summary></td></tr>
<tr valign="top"><td><pre>val tryFind : ('T -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> 'T <a href='Microsoft.FSharp.Core.type__option-1.html'>option</a></pre></td><td><summary>
 Return the first element for which the given function returns <tt>true</tt>.
 Return <tt>None</tt> if no such element exists.
</summary></td></tr>
<tr valign="top"><td><pre>val tryFindIndex : ('T -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Core.type__int.html'>int</a> <a href='Microsoft.FSharp.Core.type__option-1.html'>option</a></pre></td><td><summary>
 Return the index of the first element in the sequence 
 that satisfies the given predicate. Return 'None' if no such element exists.
</summary></td></tr>
<tr valign="top"><td><pre>val tryPick : ('T -> 'U <a href='Microsoft.FSharp.Core.type__option-1.html'>option</a>) -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> 'U <a href='Microsoft.FSharp.Core.type__option-1.html'>option</a></pre></td><td><summary>
 Apply the given function to successive elements, returning the first
 result where the function returns "Some(x)".
</summary></td></tr>
<tr valign="top"><td><pre>val unfold : ('State -> ('T * 'State) <a href='Microsoft.FSharp.Core.type__option-1.html'>option</a>) -> 'State -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt;</pre></td><td><summary>
 Return a sequence that contains the elements generated by the given computation.
 The given initial 'state' argument is passed to the element generator.
 For each IEnumerator elements in the stream are generated on-demand by applying the element
 generator, until a None value is returned by the element generator. Each call to the element
 generator returns a new residual 'state'.

 Note the stream will be recomputed each time an IEnumerator is requested and iterated for the Seq.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
</summary></td></tr>
<tr valign="top"><td><pre>val windowed : <a href='Microsoft.FSharp.Core.type__int.html'>int</a> -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T <a href='../FSharp.Core/Microsoft.FSharp.Core.type__[]-1.html'>[]</a>&gt;</pre></td><td><summary>
 Return a sequence that yields 'sliding windows' of containing elements drawn from the input
 sequence. Each window is returned as a fresh array.
</summary></td></tr>
<tr valign="top"><td><pre>val zip : <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T1&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T2&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T1 * 'T2&gt;</pre></td><td><summary>
 Combine the two sequences into a list of pairs. The two sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequence are ignored.
</summary></td></tr>
<tr valign="top"><td><pre>val zip3 :
  <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T1&gt; ->
    <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T2&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T3&gt; -> <a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T1 * 'T2 * 'T3&gt;</pre></td><td><summary>
 Combine the three sequences into a list of triples. The two sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequence are ignored.
</summary></td></tr>

</table>
  </dd>
  </td></tr>
  <tr valign='top'><td>
  <dt><h3>See Also</h3></dt><dd>
<a href="Microsoft.FSharp.Collections.html">Microsoft.FSharp.Collections</a>  </dd>
  </td></tr>
</table>
</dd>
</dl>
<br /> <br/><p><i>Documentation for assembly FSharp.Core, version 1.9.6.16, generated using <a href='http://research.microsoft.com/fsharp/'>F# Programming Language</a> version 1.9.6.16</i></p>
</BODY></HTML>

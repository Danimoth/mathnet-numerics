<HTML><HEAD><TITLE>Microsoft.FSharp.Collections.Set</TITLE><link rel="stylesheet" type="text/css"href="../msdn.css"></link></HEAD><BODY>
<br><dl>
<dt></dt><dd>
<h1>[<a href='../namespaces.html'>Home</a>] Type <a href='Microsoft.FSharp.Collections.html'>Microsoft.FSharp.Collections</a>.Set </h1><br>
</dd>
<dt></dt><dd>
<table>
  <tr valign='top'><td><summary>
 Immutable sets based on binary trees, where comparison is the
 F# structural comparison function, potentially using implementations
 of the IComparable interface on key values.

 See the Set module for further operations on sets.

 These sets can be used with elements of any type, but you should check that
 structural hashing and equality on the element type are correct for your type.  
</summary>
  <dt><h3>Full Type Signature</h3></dt><dd>
<pre>[<<a href='Microsoft.FSharp.Core.type_SealedAttribute.html'>SealedAttribute</a> ()>]
type Set&lt;'T&gt; =
  class
    interface <a href='http://msdn2.microsoft.com/en-us/library/System.IComparable.aspx'>IComparable</a>
    interface <a href='http://msdn2.microsoft.com/en-us/library/System.Collections.IEnumerable.aspx'>IEnumerable</a>
    interface IEnumerable&lt;'T&gt;
    interface ICollection&lt;'T&gt;
    new : elements:<a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt;
    member Add : value:'T -> <a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt;
    member Contains : value:'T -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a>
    override Equals : <a href='Microsoft.FSharp.Core.type__obj.html'>obj</a> -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a>
    member IsSubsetOf : set:<a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a>
    member IsSupersetOf : set:<a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a>
    member Remove : value:'T -> <a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt;
    member Count : <a href='Microsoft.FSharp.Core.type__int.html'>int</a>
    member IsEmpty : <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a>
    member MaximumElement : 'T
    member MinimumElement : 'T
    static member Subtract : set1:<a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt; * set2:<a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt;
    static member Empty : <a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt;
    static member ( + ) : set1:<a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt; * set2:<a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt;
    static member ( - ) : set1:<a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt; * set2:<a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt;
  end</pre>  </dd>
  <dt><h3>Instance Members</h3></dt><dd>
<table width="100%%">
<tr><th width=60%>Member</th><th>Description</th></tr>
<tr valign="top"><td><pre>member Add : value:'T -> <a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt;</pre></td><td><summary>
 A useful shortcut for Set.add.  Note this operation produces a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary></td></tr>
<tr valign="top"><td><pre>member Contains : value:'T -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a></pre></td><td><summary>
 A useful shortcut for Set.contains.  See the Set module for further operations on sets.
</summary></td></tr>
<tr valign="top"><td><pre>member Count : <a href='Microsoft.FSharp.Core.type__int.html'>int</a></pre></td><td><summary>
 The number of elements in the set
</summary></td></tr>
<tr valign="top"><td><pre>override Equals : <a href='Microsoft.FSharp.Core.type__obj.html'>obj</a> -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a></pre></td><td></td></tr>
<tr valign="top"><td><pre>member IsEmpty : <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a></pre></td><td><summary>
 A useful shortcut for Set.isEmpty.  See the Set module for further operations on sets.
</summary></td></tr>
<tr valign="top"><td><pre>member IsSubsetOf : set:<a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a></pre></td><td><summary>
 Evaluates to "true" if all elements of the second set are in the first
</summary></td></tr>
<tr valign="top"><td><pre>member IsSupersetOf : set:<a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Core.type__bool.html'>bool</a></pre></td><td><summary>
 Evaluates to "true" if all elements of the first set are in the second
</summary></td></tr>
<tr valign="top"><td><pre>member MaximumElement : 'T</pre></td><td><summary>
 Returns the highest element in the set according to the ordering being used for the set
</summary></td></tr>
<tr valign="top"><td><pre>member MinimumElement : 'T</pre></td><td><summary>
 Returns the lowest element in the set according to the ordering being used for the set
</summary></td></tr>
<tr valign="top"><td><pre>member Remove : value:'T -> <a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt;</pre></td><td><summary>
 A useful shortcut for Set.remove.  Note this operation produces a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary></td></tr>

</table>
  </dd>
  <dt><h3>Static Members</h3></dt><dd>
<table width="100%%">
<tr><th width=60%>Member</th><th>Description</th></tr>
<tr valign="top"><td><pre>member ( + ) : set1:<a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt; * set2:<a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt;</pre></td><td><summary>
 Compute the union of the two sets.
</summary></td></tr>
<tr valign="top"><td><pre>member ( - ) : set1:<a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt; * set2:<a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt;</pre></td><td><summary>
 Return a new set with the elements of the second set removed from the first.
</summary></td></tr>
<tr valign="top"><td><pre>new : elements:<a href='Microsoft.FSharp.Collections.type__seq-1.html'>seq</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt;</pre></td><td><summary>
 Create a set containing elements drawn from the given sequence.
</summary></td></tr>
<tr valign="top"><td><pre>member Empty : <a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt;</pre></td><td><summary>
 The empty set for the type 'T.
</summary></td></tr>
<tr valign="top"><td><pre>member Subtract : set1:<a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt; * set2:<a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt; -> <a href='Microsoft.FSharp.Collections.type_Set-1.html'>Set</a>&lt;'T&gt;</pre></td><td><summary>
 Return a new set with the elements of the second set removed from the first.
</summary></td></tr>

</table>
  </dd>
  </td></tr>
  <tr valign='top'><td>
  <dt><h3>See Also</h3></dt><dd>
<a href="Microsoft.FSharp.Collections.html">Microsoft.FSharp.Collections</a>  </dd>
  </td></tr>
</table>
</dd>
</dl>
<br /> <br/><p><i>Documentation for assembly FSharp.Core, version 1.9.6.16, generated using <a href='http://research.microsoft.com/fsharp/'>F# Programming Language</a> version 1.9.6.16</i></p>
</BODY></HTML>

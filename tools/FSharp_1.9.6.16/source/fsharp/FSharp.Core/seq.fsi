//=========================================================================
// (c) Microsoft Corporation 2005-2009. 
//=========================================================================

namespace Microsoft.FSharp.Collections

    open System
    open System.Collections
    open System.Collections.Generic
    open Microsoft.FSharp.Core
    open Microsoft.FSharp.Collections
        

    /// Basic operations on IEnumerables.  
    [<RequireQualifiedAccess>]
    [<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
    module Seq = 

        /// Wrap the two given enumeration-of-enumerations as a single concatenated
        /// enumeration.
        ///
        /// The returned sequence may be passed between threads safely. However, 
        /// individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
        
        val append: sequence1:seq<'T>  -> sequence2:seq<'T> -> seq<'T> 

        /// Return the average of the elements in the sequence
        ///
        /// The elements are averaged using the '+' operator, 'DivideByInt' method and 'Zero' property 
        /// associated with the element type.
        val inline average   : sequence:seq<(^T)> -> ^T 
                                      when ^T : (static member ( + ) : ^T * ^T -> ^T) 
                                      and  ^T : (static member DivideByInt : ^T * int -> ^T) 
                                      and  ^T : (static member Zero : ^T)

        /// Return the average of the results generated by applying the function to each element of the sequence.
        ///
        /// The elements are averaged using the '+' operator, 'DivideByInt' method and 'Zero' property 
        /// associated with the generated type.
        val inline averageBy   : projection:('T -> ^U) -> sequence:seq<'T>  -> ^U 
                                      when ^U : (static member ( + ) : ^U * ^U -> ^U) 
                                      and  ^U : (static member DivideByInt : ^U * int -> ^U) 
                                      and  ^U : (static member Zero : ^U)

        /// Return a sequence that corresponds to a cached version of the input sequence.
        /// This result sequence will have the same elements as the input sequence. The result 
        /// can be enumerated multiple times. The input sequence will be enumerated at most 
        /// once and only as far as is necessary.
        ///
        /// Enumeration of the result sequence is thread safe in the sense that multiple independent IEnumerator
        /// values may be used simultaneously from different threads (accesses to 
        /// the internal lookaside table are thread safe). Each individual IEnumerator
        /// is not typically thread safe and should not be accessed concurrently.
        ///
        /// Note, once enumeration of the input sequence has started,
        /// it's enumerator will be kept live by this object until the enumeration has completed.
        /// At that point, the enumerator will be disposed. 
        ///
        /// The enumerator may be disposed and underlying cache storage released by 
        /// converting the returned sequence object to type IDisposable, and calling the Dispose method
        /// on this object. The sequence object may then be re-enumerated and a fresh enumerator will
        /// be used.
        val cache: sequence:seq<'T> -> seq<'T>

        /// Wrap a loosely-typed System.Collections sequence as a typed sequence.
        ///
        /// The use of this function usually requires a type annotation.
        /// An incorrect type annotation may result in runtime type
        /// errors.
        ///
        /// Individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
        
        val cast: sequence:IEnumerable -> seq<'T>

        /// Apply the given function to each element of the list. Return
        /// the list comprised of the results "x" for each element where
        /// the function returns Some(x)
        ///
        /// The returned sequence may be passed between threads safely. However, 
        /// individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
        
        ///
        /// Remember sequence is lazy, effects are delayed until it is enumerated.
        val choose: chooser:('T -> 'U option) -> sequence:seq<'T> -> seq<'U>

        /// For each element of the enumeration apply the given function and concatenate all the results.
        ///
        /// Remember sequence is lazy, effects are delayed until it is enumerated.    
        val collect: mapping:('T -> #seq<'U>) -> sequence:seq<'T> -> seq<'U> 

        /// Compare two sequence's using generic comparison, element by element.
        val compare: comparer:('T -> 'T -> int) -> sequence1:seq<'T> -> sequence2:seq<'T> -> int

        /// Compare two sequence's using the given comparison function, element by element.
        val compareWith: comparer:('T -> 'T -> int) -> sequence1:seq<'T> -> sequence2:seq<'T> -> int

        /// Wrap the given enumeration-of-enumerations as a single concatenated
        /// enumeration.
        ///
        /// The returned sequence may be passed between threads safely. However, 
        /// individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
        
        val concat: sequences:seq<#seq<'T>> -> seq<'T> 


        /// Apply a key-generating function to each element of a sequence and return a sequence yielding unique
        /// keys and their number of occurences in the original sequence.  
        /// 
        /// Note that this function returns a sequence that digests the whole initial sequence as soon as 
        /// that sequence is iterated. As a result this function should not be used with 
        /// large or infinite sequences. The function makes no assumption on the ordering of the original 
        /// sequence.
        val countBy : projection:('T -> 'Key) -> sequence:seq<'T> -> seq<'Key * int>

        /// Return a sequence that is built from the given delayed specification of an
        /// Seq. The input function is evaluated each time an IEnumerator for the sequence 
        /// is requested.
        val delay   : generator:(unit -> seq<'T>) -> seq<'T>

        /// Return a sequence that contains no duplicate entries according to generic hash and equality comparisons on the entries.
        /// If an element occurs multiple times in the sequence then the later occurrences are discarded.
        val distinct: sequence:seq<'T> -> seq<'T>

        /// Return a sequence that contains no duplicate entries according to the 
        /// generic hash and equality comparisons on the keys returned by the given key-generating function.
        /// If an element occurs multiple times in the sequence then the later occurrences are discarded.
        val distinctBy: projection:('T -> 'Key) -> sequence:seq<'T> -> seq<'T>

        /// Create an empty sequence 
        [<GeneralizableValueAttribute>]
        val empty<'T> : seq<'T>

        /// Test if any element of the sequence satisfies the given predicate.
        ///
        /// The predicate is applied to the elements of the input sequence. If any application 
        /// returns true then the overall result is true and no further elements are tested. 
        /// Otherwise, false is returned.
        val exists: predicate:('T -> bool) -> sequence:seq<'T> -> bool

        /// Test if any pair of corresponding elements of the input sequences satisfies the given predicate.
        ///
        /// The predicate is applied to matching elements in the two sequences up to the lesser of the 
        /// two lengths of the collections. If any application returns true then the overall result is 
        /// true and no further elements are tested. Otherwise, false is returned. If one sequence is shorter than 
        /// the other then the remaining elements of the longer sequence are ignored.
        val exists2: predicate:('T1 -> 'T2 -> bool) -> sequence1:seq<'T1> -> sequence2:seq<'T2> -> bool

        /// Return a new collection containing only the elements of the collection
        /// for which the given predicate returns "true"
        ///
        /// The returned sequence may be passed between threads safely. However, 
        /// individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
        
        ///
        /// Remember sequence is lazy, effects are delayed until it is enumerated.      
        val filter: predicate:('T -> bool) -> sequence:seq<'T> -> seq<'T>

        /// Return the first element for which the given function returns <c>true</c>.
        /// Raise <c>KeyNotFoundException</c> if no such element exists.
        val find: predicate:('T -> bool) -> sequence:seq<'T> -> 'T

        /// Return the index of the first element in the sequence of pairs
        /// that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if no such element exists.
        val findIndex: predicate:('T -> bool) -> sequence:seq<'T> -> int

        /// Apply a function to each element of the collection, threading an accumulator argument
        /// through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
        /// then computes <c>f (... (f s i0)...) iN</c>
        val fold: folder:('State -> 'T -> 'State) -> state:'State -> sequence:seq<'T> -> 'State

        /// Test if all elements of the sequence satisfy the given predicate.
        ///
        /// The predicate is applied to the elements of the input sequence. If any application 
        /// returns false then the overall result is false and no further elements are tested. 
        /// Otherwise, true is returned.
        val forall: predicate:('T -> bool) -> sequence:seq<'T> -> bool

        /// Test the all pairs of elements drawn from the two sequences satisfies the
        /// given predicate. If one sequence is shorter than 
        /// the other then the remaining elements of the longer sequence are ignored
        val forall2: predicate:('T1 -> 'T2 -> bool) -> sequence1:seq<'T1> -> sequence2:seq<'T2> -> bool

        /// Apply a key-generating function to each element of a sequence and yields a sequence of 
        /// unique keys. Each unique key has also contains a sequence of all elements that match 
        /// to this key. 
        /// 
        /// Note that this function returns a sequence that digests the whole initial sequence as soon as 
        /// that sequence is iterated. As a result this function should not be used with 
        /// large or infinite sequences. The function makes no assumption on the ordering of the original 
        /// sequence.
        val groupBy : projection:('T -> 'Key) -> sequence:seq<'T> -> seq<'Key * seq<'T>>

        /// Return the first element of the sequence.  
        val hd: sequence:seq<'T> -> 'T

        /// Return true if the sequence contains no elements, false otherwise
        val isEmpty: sequence:seq<'T> -> bool

        /// Generate a new sequence which, when iterated, will return successive
        /// elements by calling the given function, up to the given count.  The results of calling the function
        /// will not be saved, i.e. the function will be reapplied as necessary to
        /// regenerate the elements.  The function is passed the index of the item being
        /// generated.
        ///
        /// The returned sequence may be passed between threads safely. However, 
        /// individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
        
        val init: count:int -> initializer:(int -> 'T) -> seq<'T>
        
        /// Generate a new sequence which, when iterated, will return successive
        /// elements by calling the given function.  The results of calling the function
        /// will not be saved, i.e. the function will be reapplied as necessary to
        /// regenerate the elements.  The function is passed the index of the item being
        /// generated
        ///
        /// The returned sequence may be passed between threads safely. However, 
        /// individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
        
        val initInfinite: initializer:(int -> 'T) -> seq<'T>

        /// Apply the given function to each element of the collection. 
        val iter: action:('T -> unit) -> sequence:seq<'T> -> unit

        /// Apply the given function to each element of the collection. The integer passed to the
        /// function indicates the index of element.
        val iteri: action:(int -> 'T -> unit) -> sequence:seq<'T> -> unit

        /// Apply the given function to two collections simultaneously. If one sequence is shorter than 
        /// the other then the remaining elements of the longer sequence are ignored.
        val iter2: action:('T1 -> 'T2 -> unit) -> sequence1:seq<'T1> -> sequence2:seq<'T2> -> unit

        /// Return the length of the sequence
        val length: sequence:seq<'T> -> int

        /// Build a new collection whose elements are the results of applying the given function
        /// to each of the elements of the collection.  The given function will be applied
        /// as elements are demanded using the 'MoveNext' method on enumerators retrieved from the
        /// object.  
        ///
        /// The returned sequence may be passed between threads safely. However, 
        /// individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
        val map  : mapping:('T -> 'U) -> sequence:seq<'T> -> seq<'U>

        /// Build a new collection whose elements are the results of applying the given function
        /// to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than 
        /// the other then the remaining elements of the longer sequence are ignored.
        val map2: mapping:('T1 -> 'T2 -> 'U) -> sequence1:seq<'T1> -> sequence2:seq<'T2> -> seq<'U>

        /// Build a new collection whose elements are the results of applying the given function
        /// to each of the elements of the collection. The integer index passed to the
        /// function indicates the index (from 0) of element being transformed.
        val mapi: mapping:(int -> 'T -> 'U) -> sequence:seq<'T> -> seq<'U>

        /// Return the greatest of all elements of the sequence, compared via Operators.max
        val max     : sequence:seq<'T> -> 'T 

        /// Return the greatest of all elements of the array, compared via Operators.max on the function result
        val maxBy  : projection:('T -> 'Key) -> sequence:seq<'T> -> 'T

        /// Return the lowest of all elements of the sequence, compared via Operators.min
        val min     : sequence:seq<'T> -> 'T 

        /// Return the lowest of all elements of the array, compared via Operators.min on the function result
        val minBy  : projection:('T -> 'Key) -> sequence:seq<'T> -> 'T

        /// Compute the nth element in the collection.
        val nth: index:int -> sequence:seq<'T> -> 'T

        /// Build a collection from the given array
        val of_array: elements:'T array -> seq<'T>

        /// Build a collection from the given array
        val of_list: elements:'T list -> seq<'T>

        /// Return a sequence of each element in the input sequence and its predecessor, with the
        /// exception of the first element which is only returned as the predecessor of the second element.
        val pairwise: sequence:seq<'T> -> seq<'T * 'T>

        /// Apply the given function to successive elements, returning the first
        /// 'x' where the function returns "Some(x)".
        val pick: chooser:('T -> 'U option) -> sequence:seq<'T> -> 'U 

        /// Build a new sequence object that delegates to the given sequence object. This ensures 
        /// the original sequence can't be rediscovered and mutated by a type cast. For example, 
        /// if given an array the returned sequence will return the elements of the array, but
        /// you can't cast the returned sequence object to an array.
        val readonly : sequence:seq<'T> -> seq<'T>

        /// Apply a function to each element of the sequence, threading an accumulator argument
        /// through the computation. Begin by applying the function to the first two elements.
        /// Then feed this result into the function along with the third element and so on.  
        /// Return the final result.
        /// Raises ArgumentException if the sequence has no elements.    
        val reduce: reduction:('T -> 'T -> 'T) -> sequence:seq<'T> -> 'T

        /// Like fold, but compute on-demand and return the sequence of intermediary and final results
        val scan : folder:('State -> 'T -> 'State) -> state:'State -> sequence:seq<'T> -> seq<'State>

        /// Return a sequence that yields one item only.
        val singleton: value:'T -> seq<'T>

        /// Return a sequence that skips N elements of the underlying sequence and then yields the
        /// remaining elements of the sequence
        val skip: count:int -> sequence:seq<'T> -> seq<'T>

        /// Return a sequence that, when iterated, skips elements of the underlying sequence while the 
        /// given predicate returns 'true', and then yields the remaining elements of the sequence
        val skipWhile: predicate:('T -> bool) -> sequence:seq<'T> -> seq<'T>

        /// Yield a sequence ordered by keys.  
        /// 
        /// Note that this function returns a sequence that digests the whole initial sequence as soon as 
        /// that sequence is iterated. As a result this function should not be used with 
        /// large or infinite sequences. The function makes no assumption on the ordering of the original 
        /// sequence.
        val sort : sequence:seq<'T> -> seq<'T>

        /// Apply a key-generating function to each element of a sequence and yield a sequence ordered
        /// by keys.  The keys are compared using generic comparison as implemented by <c>Operators.compare</c>. 
        /// 
        /// Note that this function returns a sequence that digests the whole initial sequence as soon as 
        /// that sequence is iterated. As a result this function should not be used with 
        /// large or infinite sequences. The function makes no assumption on the ordering of the original 
        /// sequence.
        val sortBy : projection:('T -> 'Key) -> sequence:seq<'T> -> seq<'T>

        /// Return the sum of the elements in the sequence.
        ///
        /// The elements are summed using the '+' operator and 'Zero' property associated with the generated type.
        val inline sum   : sequence:seq<(^T)> -> ^T 
                                      when ^T : (static member ( + ) : ^T * ^T -> ^T) 
                                      and  ^T : (static member Zero : ^T)

        /// Return the sum of the results generated by applying the function to each element of the sequence.
        /// The generated elements are summed using the '+' operator and 'Zero' property associated with the generated type.
        val inline sumBy   : projection:('T -> ^U) -> sequence:seq<'T>  -> ^U 
                                      when ^U : (static member ( + ) : ^U * ^U -> ^U) 
                                      and  ^U : (static member Zero : ^U)

        /// Return the first N elements of the sequence.  
        val take: count:int -> sequence:seq<'T> -> seq<'T>

        /// Return a sequence that, when iterated, yields elements of the underlying sequence while the 
        /// given predicate returns 'true', and returns no further elements 
        val takeWhile: predicate:('T -> bool) -> sequence:seq<'T> -> seq<'T>

        /// Build an array from the given collection
        val to_array: sequence:seq<'T> -> 'T array

        /// Build a list from the given collection
        val to_list: sequence:seq<'T> -> 'T list

        /// Return the first element for which the given function returns <c>true</c>.
        /// Return <c>None</c> if no such element exists.
        val tryFind: predicate:('T -> bool) -> sequence:seq<'T> -> 'T option

        /// Return the index of the first element in the sequence 
        /// that satisfies the given predicate. Return 'None' if no such element exists.
        val tryFindIndex : predicate:('T -> bool) -> sequence:seq<'T> -> int option

        /// Apply the given function to successive elements, returning the first
        /// result where the function returns "Some(x)".
        val tryPick: chooser:('T -> 'U option) -> sequence:seq<'T> -> 'U option

        /// Return a sequence that when enumerated returns at most N elements.
        val truncate: count:int -> sequence:seq<'T> -> seq<'T>

        /// Return a sequence that contains the elements generated by the given computation.
        /// The given initial 'state' argument is passed to the element generator.
        /// For each IEnumerator elements in the stream are generated on-demand by applying the element
        /// generator, until a None value is returned by the element generator. Each call to the element
        /// generator returns a new residual 'state'.
        ///
        /// Note the stream will be recomputed each time an IEnumerator is requested and iterated for the Seq.
        ///
        /// The returned sequence may be passed between threads safely. However, 
        /// individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
        
        val unfold   : generator:('State -> ('T * 'State) option) -> state:'State -> seq<'T>

        /// Return a sequence that yields 'sliding windows' of containing elements drawn from the input
        /// sequence. Each window is returned as a fresh array.
        val windowed: windowSize:int -> sequence:seq<'T> -> seq<'T[]>

        /// Combine the two sequences into a list of pairs. The two sequences need not have equal lengths:
        /// when one sequence is exhausted any remaining elements in the other
        /// sequence are ignored.
        val zip: sequence1:seq<'T1> -> sequence2:seq<'T2> -> seq<'T1 * 'T2>

        /// Combine the three sequences into a list of triples. The two sequences need not have equal lengths:
        /// when one sequence is exhausted any remaining elements in the other
        /// sequence are ignored.
        val zip3: sequence1:seq<'T1> -> sequence2:seq<'T2> -> sequence3:seq<'T3> -> seq<'T1 * 'T2 * 'T3>

#if DONT_INCLUDE_DEPRECATED
#else
        [<Obsolete("This F# library function has been renamed. Use 'groupBy' instead")>]
        val group_by : projection:('T -> 'Key) -> sequence:seq<'T> -> seq<'Key * seq<'T>>

        [<Obsolete("This F# library function has been renamed. Use 'isEmpty' instead")>]
        val is_empty: sequence:seq<'T> -> bool

        [<Obsolete("This F# library function has been renamed. Use 'tryPick' instead")>]
        val first: chooser:('T -> 'U option) -> sequence:seq<'T> -> 'U option

        [<Obsolete("This F# library function has been renamed. Use 'forall' instead")>]
        val for_all: predicate:('T -> bool) -> sequence:seq<'T> -> bool

        [<Obsolete("This F# library function has been renamed. Use 'forall2' instead")>]
        val for_all2: predicate:('T1 -> 'T2 -> bool) -> sequence1:seq<'T1> -> sequence2:seq<'T2> -> bool

      
        [<Obsolete("This function will be removed from the F# library. Replacement functions 'pick' and 'findIndex' are now provided, though with a different signature")>]
        val find_index: predicate:('T -> bool) -> sequence:seq<'Key * 'T> -> 'Key

        [<Obsolete("This function will be removed from the F# library. Replacement functions 'pick' and 'findIndex' are now provided, though with a different signature")>]
        val find_indexi: predicate:('Key -> 'T -> bool) -> sequence:seq<'Key * 'T> -> 'Key

        [<Obsolete("This F# library function has been renamed. Use 'tryFind' instead")>]
        val tryfind: predicate:('T -> bool) -> sequence:seq<'T> -> 'T option

        [<Obsolete("This function will be removed from the F# library. Replacement functions 'tryPick' and 'tryFindIndex' are now provided, though with a different signature")>]
        val tryfind_index : predicate:('T -> bool) -> sequence:seq<'Key * 'T> -> 'Key option
      
        [<Obsolete("This function will be removed from the F# library. Replacement functions 'tryPick' and 'tryFindIndex' are now provided, though with a different signature")>]
        val tryfind_indexi : predicate:('Key -> 'T -> bool) -> sequence:seq<'Key * 'T> -> 'Key option
      
        [<Obsolete("This F# library function has been renamed. Use 'collect' instead")>]
        val map_concat: mapping:('T -> #seq<'U>) -> sequence:seq<'T> -> seq<'U> 

        [<Obsolete("This F# library function has been renamed. Use 'init' instead")>]
        val init_finite: count:int -> initializer:(int -> 'T) -> seq<'T>

        [<Obsolete("This F# library function has been renamed. Use 'initInfinite' instead")>]
        val init_infinite: initializer:(int -> 'T) -> seq<'T>

        [<Obsolete("This F# library function has been renamed. Use 'takeWhile' instead")>]
        val take_while: predicate:('T -> bool) -> sequence:seq<'T> -> seq<'T>
        
        [<Obsolete("This F# library function has been renamed. Use 'skipWhile' instead")>]
        val skip_while: predicate:('T -> bool) -> sequence:seq<'T> -> seq<'T>
            
        [<Obsolete("This F# library function has been renamed. Use 'distinctBy' instead")>]
        val distinct_by : projection:('T -> 'Key) -> sequence:seq<'T> -> seq<'T>

        [<Obsolete("This F# library function has been renamed. Use 'countBy' instead")>]
        val count_by : projection:('T -> 'Key) -> sequence:seq<'T> -> seq<'Key * int>

        [<Obsolete("This F# library function has been renamed. Use 'sortBy' instead")>]
        val sort_by : projection:('T -> 'Key) -> sequence:seq<'T> -> seq<'T>


        [<Obsolete("This F# library function has been renamed. Use 'sumBy' instead")>]
        val inline sum_by   : projection:('T -> ^U) -> sequence:seq<'T>  -> ^U 
                                      when ^U : (static member ( + ) : ^U * ^U -> ^U) 
                                      and  ^U : (static member Zero : ^U)

        [<Obsolete("This F# library function has been renamed. Use 'averageBy' instead")>]
        val inline average_by   : projection:('T -> ^U) -> sequence:seq<'T>  -> ^U 
                                      when ^U : (static member ( + ) : ^U * ^U -> ^U) 
                                      and  ^U : (static member DivideByInt : ^U * int -> ^U) 
                                      and  ^U : (static member Zero : ^U)

        [<Obsolete("This F# library function has been renamed. Use 'minBy' instead")>]
        val min_by  : projection:('T -> 'Key) -> sequence:seq<'T> -> 'T

        [<Obsolete("This F# library function has been renamed. Use 'maxBy' instead")>]
        val max_by  : projection:('T -> 'Key) -> sequence:seq<'T> -> 'T
#endif
        
    [<RequireQualifiedAccess>]
    /// A group of functions used as part of the compiled representation of F# sequence expressions
    module SequenceExpressionHelpers = 

        /// The F# compiler emits calls to this function to 
        /// implement the 'while' operator for F# sequence expressions
        val EnumerateWhile   : guard:(unit -> bool) -> sequence:seq<'T> -> seq<'T>

        /// The F# compiler emits calls to this function to 
        /// implement the 'try/finally' operator for F# sequence expressions
        val EnumerateThenFinally :  sequence:seq<'T> -> compensation:(unit -> unit) -> seq<'T>
        
        /// The F# compiler emits calls to this function to implement the compiler-intrinsic
        /// conversions from untyped System.Collections.IEnumerable sequences to typed sequences
        val EnumerateFromFunctions: create:(unit -> 'T) -> moveNext:('T -> bool) -> current:('T -> 'U) -> seq<'U>

        /// The F# compiler emits calls to this function to implement the 'use' operator for F# sequence expressions
        val EnumerateUsing : resource:'T -> sequence:('T -> #seq<'U>) -> seq<'U> when 'T :> IDisposable

        [<AbstractClass>]
        /// The F# compiler emits implementations of this type for compiled sequence expressions
        type GeneratedSequenceBase<'T> =
            /// The F# compiler emits implementations of this method for compiled sequence expressions
            new : unit -> GeneratedSequenceBase<'T>
            /// The F# compiler emits implementations of this method for compiled sequence expressions
            abstract GetFreshEnumerator : unit -> IEnumerator<'T>
            /// The F# compiler emits implementations of this method for compiled sequence expressions
            abstract GenerateNext : next:byref<IEnumerable<'T>> -> int
            /// The F# compiler emits implementations of this method for compiled sequence expressions
            abstract Close: unit -> unit
            /// The F# compiler emits implementations of this method for compiled sequence expressions
            abstract CheckClose: bool
            /// The F# compiler emits implementations of this method for compiled sequence expressions
            abstract LastGenerated : 'T
            interface IEnumerable<'T> 
            interface IEnumerable
            interface IEnumerator<'T> 
            interface IEnumerator 


//==========================================================================
// (c) Microsoft Corporation 2005-2009.
//=========================================================================

#if INTERNALIZED_POWER_PACK
namespace  Internal.Utilities.Text.Parsing
open Internal.Utilities
open Internal.Utilities.Text.Lexing
#else
namespace Microsoft.FSharp.Text.Parsing
open Microsoft.FSharp.Text.Lexing
#endif

open System.Collections.Generic

/// Parsers generated by FsPars provide information from within parser
/// actions.  This is accessed via the functions available on the local
/// variable <c>parseState</c> within parser actions
type IParseState = 
    abstract InputRange: int -> Position * Position
    abstract InputEndPosition: int -> Position 
    abstract InputStartPosition: int -> Position 
    abstract ResultRange: Position * Position
    abstract GetInput   : int -> obj 
    // Dynamically typed, non-lexically scoped local store
    abstract ParserLocalStore : IDictionary<string,obj>
    abstract RaiseError<'b> : unit -> 'b 


[<Sealed>]
type ParseErrorContext<'tok> =
      member StateStack  : int list
      member ParseState : IParseState
      member ReduceTokens: int list
      member ReducibleProductions : int list list
      member CurrentToken : 'tok option
      member ShiftTokens : int list
      member Message : string

/// Tables generated by fsyacc
type Tables<'tok> = 
    { reductions: (IParseState -> obj) array ;
      endOfInputTag: int;
      tagOfToken: 'tok -> int;
      dataOfToken: 'tok -> obj; 
      // The Action table
      actionTableElements: uint16[];
      actionTableRowOffsets: uint16[];
      // The number of symbols for each reduction
      reductionSymbolCounts: uint16[];
      immediateActions: uint16[];      
      // The Goto table
      gotos: uint16[];
      sparseGotoTableRowOffsets: uint16[];
      // This table tells us which productions are active for which states
      stateToProdIdxsTableElements: uint16[];  
      stateToProdIdxsTableRowOffsets: uint16[];  
      // This table is logically part of the Goto table
      productionToNonTerminalTable: uint16[];
      // This function is used to hold the user specified "parse_error" or "parse_error_rich" functions
      parseError:  ParseErrorContext<'tok> -> unit;
      // This holds the total number of terminals 
      numTerminals: int;
      tagOfErrorTerminal: int }
    member Interpret :  lexer:(LexBuffer<'char> -> 'tok) * lexbuf:LexBuffer<'char> * startState:int -> obj 

exception Accept of obj
exception RecoverableParseError

module ParseHelpers =
   val parse_error_rich: (ParseErrorContext<'tok> -> unit) option
   val parse_error: string -> unit

